<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="When you need a break from doomscrolling, scroll cats!">
  <title>Endless Mew Scroller üò∏</title>
  <style>
    /* ===== GLOBAL STYLES ===== */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #330066 0%, #7744AA 100%);
      min-height: 100vh;
      padding: 20px;
    }

    a:link, a:visited { color: #0099CC; }
    a:hover, a:active { color: #007AA3; text-decoration: none; }

    /* ===== CONTAINER ===== */
    #image-container {
      max-width: 600px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    /* ===== IMAGE WRAPPER ===== */
    .image-wrapper {
      width: 100%;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      opacity: 0;
      transition: opacity 0.3s ease;
      position: relative;
    }

    .image-wrapper.loaded {
      opacity: 1;
    }

    .image-wrapper img {
      width: 100%;
      height: auto;
      display: block;
    }

    /* ===== TAG DISPLAY ===== */
    .image-tags {
      position: absolute;
      bottom: 10px;
      left: 10px;
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .image-wrapper:hover .image-tags {
      opacity: 1;
    }

    .tag {
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      backdrop-filter: blur(4px);
    }

    /* ===== SENTINEL ===== */
    #sentinel {
      height: 1px;
      opacity: 0;
      pointer-events: none;
    }

    /* ===== HEADER ===== */
    header {
      text-align: center;
      color: white;
      margin-bottom: 40px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 10px;
      text-wrap: balance;
    }

    .subtitle {
      font-size: 1.1rem;
      text-wrap: balance;
    }

    button {
        border-radius: 99px;
        padding: 8px 16px;
        border: none;
        background: #fff;
        margin-top: 1em;
        cursor: pointer;
    }

    /* ===== LOADING MESSAGE ===== */
    .loading-message {
      text-align: center;
      color: white;
      padding: 40px;
      font-size: 1.2rem;
      max-width: 600px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      backdrop-filter: blur(10px);
    }

    /* ===== ERROR MESSAGE ===== */
    .error-message {
      text-align: center;
      color: white;
      padding: 40px;
      max-width: 600px;
      margin: 0 auto;
      background: rgba(255, 0, 0, 0.3);
      border-radius: 12px;
      backdrop-filter: blur(10px);
    }

    .error-message h2 {
      margin-bottom: 15px;
    }

    .error-message pre {
      background: rgba(0, 0, 0, 0.3);
      padding: 15px;
      border-radius: 8px;
      overflow-x: auto;
      text-align: left;
      font-size: 0.85rem;
      margin-top: 15px;
    }

    /* ===== DEV MODE STATS ===== */
    .stats {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 0.8rem;
      font-family: monospace;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }

    /* Accessibility: ARIA attributes should be added to the .stats element in HTML:
       <div class="stats" role="status" aria-live="polite" aria-atomic="true">...</div>
    */
    .stats div {
      margin: 2px 0;
    }
    .about {
        padding: 24px;
        border-radius: 8px;
        border: 2px solid #F5EBFF;
        background: rgba(255, 255, 255, 0.95);
        text-align: center;
        color: #121212;
        backdrop-filter: blur(10px);
        position: fixed;
        top: 24dvh;
        left: 50%;
        width: calc(100vw - 32px);
        max-width: 400px;
        transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out, overlay 0.3s ease-in-out allow-discrete, display 0.3s ease-in-out allow-discrete;
        box-shadow: 0px 8px 24px 0px #140029;
    }
    .about p {
        margin-block: .5em;
        line-height: 1.3;
    }

    .about:popover-open {
        opacity: 1;
        transform: translateX(-50%);
    }

    /* Starting style for popover animation */
    @starting-style {
        .about:popover-open {
            opacity: 0;
            transform: translate(-50%, 2rem);
        }
    }

    /* Closing state */
    .about:not(:popover-open) {
        opacity: 0;
        transform: translate(-50%, 2rem);
    }
  </style>
</head>
<body>
  <header>
    <h1>Endless Mew Scroller üò∏</h1>
    <p class="subtitle">When you need a break from doomscrolling, scroll cats!</p>
    <button popovertarget="aboutPopover">About</button>
  </header>

  <div id="loading-container">
    <div class="loading-message">
      üê± Loading cats...<br>
      <small>This may take a moment...</small>
    </div>
  </div>

  <div id="image-container">
    <!-- Cat images dynamically inserted here -->
  </div>
  <div id="sentinel"></div>
  <div id="aboutPopover" class="about" popover>
    <h3>About</h3>
    <p>An endless stream of cats.</p>
    <p>Made with <a href="https://thecatapi.com/">TheCatAPI</a> by <a href="https://github.com/kylejohnston/endlessmewscroller">Kyle</a>.</p>
    <p><a href="https://www.petfinder.com/animal-shelters-and-rescues/search/">Support your local shelter!</a></p>
  </div>


  <script>
    // ===== 1. CONFIGURATION & STATE =====
    const CONFIG = {
      // API endpoint - uses Cloudflare Pages Function to keep API key secure
      API_ENDPOINT: '/api/cats',
      BATCH_SIZE: 5,
      SCROLL_THRESHOLD: '200px',
      MAX_RETRIES: 3,
      RETRY_DELAYS: [2000, 4000, 8000],
      CLEANUP_THRESHOLD: 2000,
      CACHE_SIZE: 20,
      // Enable dev mode on localhost, file://, or if ?debug=1 is in URL
      DEV_MODE: window.location.hostname === 'localhost' ||
                window.location.hostname === '127.0.0.1' ||
                window.location.protocol === 'file:' ||
                new URLSearchParams(window.location.search).get('debug') === '1'
    };

    const estimatedImagesPerViewport = Math.ceil(window.innerHeight / 400);
    CONFIG.INITIAL_BATCH_SIZE = Math.max(estimatedImagesPerViewport * 2, 10);

    const STATE = {
      loadedImageIds: new Set(),
      isLoading: false,
      hasError: false,
      isInitialLoad: true,
      totalLoaded: 0,
      totalCleaned: 0,
      cacheHits: 0,
      apiCalls: 0
    };

    // ===== 2. API SERVICE =====
    const CatAPI = {
      cache: [],
      isRefilling: false,

      /**
       * Main fetch method - uses cache when available
       */
      async fetch(count = 5) {
        // Try cache first
        if (this.cache.length >= count) {
          const cached = this.cache.splice(0, count);
          STATE.cacheHits += count;
          this._log(`Served ${count} images from cache`);

          if (this.cache.length < CONFIG.BATCH_SIZE) {
            this._refillCache();
          }

          return cached;
        }

        // Cache miss - fetch from API and start refilling cache
        const images = await this._fetchFromAPI(count);

        // Refill cache asynchronously (don't await)
        this._refillCache().catch(err => {
          console.error('Background cache refill failed:', err);
        });

        return images;
      },

      /**
       * Fetch from TheCatAPI
       */
      async _fetchFromAPI(count) {
        STATE.apiCalls++;
        return await this._fetchFromTheCatAPI(count);
      },

      /**
       * Fetch cat images via Cloudflare Pages Function
       * The function proxies requests to TheCatAPI with the API key stored securely
       */
      async _fetchFromTheCatAPI(count) {
        this._log(`Fetching ${count} images from API`);

        const response = await fetch(
          `${CONFIG.API_ENDPOINT}?limit=${Math.min(count, 100)}`
        );

        if (!response.ok) {
          const errorText = await response.text().catch(() => 'Unable to read error response');
          console.error(`API error (${response.status}):`, errorText);

          if (response.status === 429) {
            const error = new Error('Rate limit exceeded. Please try again later.');
            error.isRateLimit = true;
            throw error;
          }
          throw new Error(`API returned ${response.status}: ${errorText}`);
        }

        const cats = await response.json();
        this._log(`Received ${cats.length} images from API`);

        return cats.map(cat => ({
          id: cat.id,
          tags: [],
          url: cat.url
        }));
      },

      /**
       * Refill cache in background
       */
      async _refillCache() {
        if (this.cache.length >= CONFIG.CACHE_SIZE || this.isRefilling) {
          this._log(`Skipping cache refill (length: ${this.cache.length}, isRefilling: ${this.isRefilling})`);
          return;
        }

        this.isRefilling = true;
        this._log('Starting cache refill...');
        try {
          const needed = CONFIG.CACHE_SIZE - this.cache.length;
          const images = await this._fetchFromTheCatAPI(needed);
          this.cache.push(...images);
          this._log(`Cache refilled: ${this.cache.length} cached`);
        } catch (error) {
          console.error('Failed to refill cache:', error);
          this._log(`Cache refill failed: ${error.message}`, 'error');
        } finally {
          this.isRefilling = false;
          this._log(`Cache refill complete (isRefilling reset to false)`);
        }
      },

      /**
       * Build image element
       */
      buildImageElement(imageData) {
        const wrapper = document.createElement('div');
        wrapper.className = 'image-wrapper';
        wrapper.dataset.imageId = imageData.id;

        const img = document.createElement('img');
        img.src = imageData.url;
        img.alt = `Cat ${imageData.tags.length > 0 ? 'tagged: ' + imageData.tags.join(', ') : ''}`;
        img.loading = 'lazy';

        img.addEventListener('load', () => {
          wrapper.classList.add('loaded');
        });

        img.addEventListener('error', () => {
          this._log(`Failed to load image: ${imageData.id}`, 'error');
          wrapper.remove();
        });

        wrapper.appendChild(img);

        if (imageData.tags && imageData.tags.length > 0) {
          const tagsContainer = document.createElement('div');
          tagsContainer.className = 'image-tags';

          imageData.tags.slice(0, 3).forEach(tag => {
            const tagEl = document.createElement('span');
            tagEl.className = 'tag';
            tagEl.textContent = tag;
            tagsContainer.appendChild(tagEl);
          });

          wrapper.appendChild(tagsContainer);
        }

        return wrapper;
      },

      _log(message, level = 'info') {
        if (CONFIG.DEV_MODE) {
          console[level](`[CatAPI] ${message}`);
        }
      }
    };

    // ===== 3. IMAGE MANAGER =====
    async function fetchNextBatch() {
      if (STATE.isLoading || STATE.hasError) {
        if (CONFIG.DEV_MODE) {
          console.log('[fetchNextBatch] Skipped - isLoading:', STATE.isLoading, 'hasError:', STATE.hasError);
        }
        return;
      }

      if (CONFIG.DEV_MODE) {
        console.log('[fetchNextBatch] Starting batch fetch...');
      }

      STATE.isLoading = true;
      updateStats();

      // Hide loading message on first batch
      if (STATE.isInitialLoad) {
        const loadingContainer = document.getElementById('loading-container');
        if (loadingContainer) {
          loadingContainer.style.display = 'none';
        }
      }

      try {
        const batchSize = STATE.isInitialLoad ? CONFIG.INITIAL_BATCH_SIZE : CONFIG.BATCH_SIZE;
        const images = await fetchWithRetry(() => CatAPI.fetch(batchSize));

        const newImages = images.filter(img => {
          if (STATE.loadedImageIds.has(img.id)) {
            return false;
          }
          STATE.loadedImageIds.add(img.id);
          return true;
        });

        const fragment = document.createDocumentFragment();
        newImages.forEach(imageData => {
          const element = CatAPI.buildImageElement(imageData);
          fragment.appendChild(element);
        });

        const container = document.getElementById('image-container');
        container.appendChild(fragment);

        STATE.totalLoaded += newImages.length;

        if (CONFIG.DEV_MODE) {
          console.log(`[fetchNextBatch] Added ${newImages.length} new images (total: ${STATE.totalLoaded})`);
        }

        if (STATE.isInitialLoad) {
          STATE.isInitialLoad = false;
        }

        cleanupOldImages();

      } catch (error) {
        console.error('Failed to fetch cat images:', error);
        STATE.hasError = true;
        showError(error);
      } finally {
        STATE.isLoading = false;
        updateStats();

        if (CONFIG.DEV_MODE) {
          console.log('[fetchNextBatch] Batch complete - isLoading reset to false');
        }
      }
    }

    async function fetchWithRetry(fetchFn, retries = 0) {
      try {
        return await fetchFn();
      } catch (error) {
        // Don't retry on rate limits - it won't help
        if (error.isRateLimit) {
          throw error;
        }

        if (retries < CONFIG.MAX_RETRIES) {
          const delay = CONFIG.RETRY_DELAYS[retries];
          console.log(`Retry ${retries + 1}/${CONFIG.MAX_RETRIES} in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          return fetchWithRetry(fetchFn, retries + 1);
        }
        throw error;
      }
    }

    // ===== 4. MEMORY MANAGEMENT =====
    function cleanupOldImages() {
      const container = document.getElementById('image-container');
      const images = container.querySelectorAll('.image-wrapper');

      if (images.length < 50) return;

      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const threshold = scrollTop - CONFIG.CLEANUP_THRESHOLD;

      let cleaned = 0;
      images.forEach(wrapper => {
        const rect = wrapper.getBoundingClientRect();
        const absoluteTop = rect.top + scrollTop;

        if (absoluteTop < threshold) {
          const imageId = wrapper.dataset.imageId;
          wrapper.remove();
          STATE.loadedImageIds.delete(imageId);
          cleaned++;
        }
      });

      if (cleaned > 0) {
        STATE.totalCleaned += cleaned;
        updateStats();
      }
    }

    // ===== 5. SCROLL CONTROLLER =====
    function handleIntersection(entries) {
      entries.forEach(entry => {
        if (entry.isIntersecting && !STATE.isLoading && !STATE.hasError) {
          fetchNextBatch();
        }
      });
    }

    function initScrollObserver() {
      const sentinel = document.getElementById('sentinel');
      const observer = new IntersectionObserver(handleIntersection, {
        root: null,
        rootMargin: CONFIG.SCROLL_THRESHOLD,
        threshold: 0
      });
      observer.observe(sentinel);
      return observer;
    }

    // ===== 6. UI UTILITIES =====
    function showError(error) {
      const loadingContainer = document.getElementById('loading-container');
      if (loadingContainer) {
        // Check if this is a rate limit error
        const isRateLimit = error.isRateLimit || error.message.toLowerCase().includes('rate limit');

        if (isRateLimit) {
          loadingContainer.innerHTML = `
            <div class="error-message">
              <h2>‚è∞ Rate Limit Reached</h2>
              <p>You've hit the API rate limit for cat images.</p>
              <p style="margin-top: 15px;">Please wait a bit and try again later.</p>
              <p style="margin-top: 10px;"><small>Rate limits typically reset within an hour.</small></p>
            </div>
          `;
        } else {
          loadingContainer.innerHTML = `
            <div class="error-message">
              <h2>üòø Failed to load cats</h2>
              <p>Unable to fetch cat images from TheCatAPI.</p>
              <pre>${error.message.replace(/</g, '&lt;').replace(/>/g, '&gt;')}\n\nCheck the browser console for details.</pre>
              <p style="margin-top: 15px;"><small>Try refreshing the page in a moment.</small></p>
            </div>
          `;
        }

        loadingContainer.style.display = 'block';
      }
    }

    function updateStats() {
      if (!CONFIG.DEV_MODE) return;

      let statsEl = document.querySelector('.stats');
      if (!statsEl) {
        statsEl = document.createElement('div');
        statsEl.className = 'stats';
        document.body.appendChild(statsEl);
      }

      const activeImages = document.querySelectorAll('.image-wrapper').length;

      statsEl.innerHTML = `
        <div>üìä Stats (TheCatAPI)</div>
        <div>Active: ${activeImages}</div>
        <div>Loaded: ${STATE.totalLoaded}</div>
        <div>Cleaned: ${STATE.totalCleaned}</div>
        <div>Cache hits: ${STATE.cacheHits}</div>
        <div>API calls: ${STATE.apiCalls}</div>
        <div>Cached: ${CatAPI.cache.length}</div>
      `;
    }

    // ===== 7. INITIALIZATION =====
    async function init() {
      console.log('üê± Endless Cat Scroller v2');
      console.log('Initializing...');

      updateStats();
      initScrollObserver();

      try {
        await fetchNextBatch();
        console.log('‚úì Initialization complete!');
      } catch (error) {
        console.error('‚úó Initialization failed:', error);
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
