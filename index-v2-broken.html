<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Endless Cat Scroller v2</title>
  <style>
    /* ===== GLOBAL STYLES ===== */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    /* ===== CONTAINER ===== */
    #image-container {
      max-width: 600px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    /* ===== IMAGE WRAPPER ===== */
    .image-wrapper {
      width: 100%;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      opacity: 0;
      transition: opacity 0.3s ease;
      position: relative;
    }

    .image-wrapper.loaded {
      opacity: 1;
    }

    .image-wrapper img {
      width: 100%;
      height: auto;
      display: block;
    }

    /* ===== TAG DISPLAY ===== */
    .image-tags {
      position: absolute;
      bottom: 10px;
      left: 10px;
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .image-wrapper:hover .image-tags {
      opacity: 1;
    }

    .tag {
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      backdrop-filter: blur(4px);
    }

    /* ===== SENTINEL ===== */
    #sentinel {
      height: 1px;
      opacity: 0;
      pointer-events: none;
    }

    /* ===== HEADER ===== */
    header {
      text-align: center;
      color: white;
      margin-bottom: 40px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
    }

    .subtitle {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    .version-badge {
      display: inline-block;
      background: rgba(255, 255, 255, 0.2);
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 0.85rem;
      margin-top: 10px;
      backdrop-filter: blur(10px);
    }

    /* ===== DEV MODE INDICATOR ===== */
    .dev-indicator {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(255, 0, 0, 0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: bold;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }

    .stats {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 0.8rem;
      font-family: monospace;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }

    .stats div {
      margin: 2px 0;
    }

    /* ===== ERROR DISPLAY (DEV MODE) ===== */
    .error-toast {
      position: fixed;
      bottom: 80px;
      right: 10px;
      background: rgba(255, 0, 0, 0.9);
      color: white;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 0.85rem;
      max-width: 300px;
      z-index: 1001;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        transform: translateX(400px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>üê± Endless Cat Scroller</h1>
    <p class="subtitle">Scroll down for infinite cats!</p>
    <div class="version-badge">v2 - Enhanced Edition</div>
  </header>

  <div id="image-container">
    <!-- Cat images dynamically inserted here -->
  </div>
  <div id="sentinel"></div>

  <script>
    // ===== 1. CONFIGURATION & STATE =====
    const CONFIG = {
      BATCH_SIZE: 5,
      SCROLL_THRESHOLD: '200px',
      MAX_RETRIES: 3,
      RETRY_DELAYS: [2000, 4000, 8000], // Exponential backoff in ms
      CLEANUP_THRESHOLD: 2000, // Remove images 2000px above viewport
      CACHE_SIZE: 20, // Pre-fetch and cache this many images
      DEV_MODE: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
    };

    // Calculate initial batch size based on viewport
    const estimatedImagesPerViewport = Math.ceil(window.innerHeight / 400);
    CONFIG.INITIAL_BATCH_SIZE = Math.max(estimatedImagesPerViewport * 2, 10);

    const STATE = {
      loadedImageIds: new Set(), // Track real API IDs
      isLoading: false,
      hasError: false,
      isInitialLoad: true,
      totalLoaded: 0,
      totalCleaned: 0,
      cacheHits: 0,
      apiCalls: 0
    };

    // ===== 2. API SERVICE (ABSTRACTION LAYER) =====
    /**
     * Generic Cat API Service
     * Encapsulates all API-specific logic and provides caching
     */
    const CatAPI = {
      provider: 'cataas', // Easy to swap providers
      cache: [], // Cache for pre-fetched images

      /**
       * Main fetch method - uses cache-first strategy
       */
      async fetch(count = 5) {
        // Try to serve from cache first
        if (this.cache.length >= count) {
          const cached = this.cache.splice(0, count);
          STATE.cacheHits += count;
          this._log(`Served ${count} images from cache (${this.cache.length} remaining)`);

          // Refill cache in background if running low
          if (this.cache.length < CONFIG.BATCH_SIZE) {
            this._refillCache();
          }

          return cached;
        }

        // Cache miss - fetch from API
        this._log(`Cache miss - fetching from API`);
        const images = await this._fetchFromAPI(count);

        // Refill cache for next time
        this._refillCache();

        return images;
      },

      /**
       * Fetch images from the API and return normalized data
       */
      async _fetchFromAPI(count) {
        STATE.apiCalls++;

        if (this.provider === 'cataas') {
          return await this._fetchFromCataas(count);
        }
        // Easy to add: else if (this.provider === 'thecatapi') { ... }

        throw new Error(`Unknown provider: ${this.provider}`);
      },

      /**
       * CATAAS.COM implementation using proper JSON API
       */
      async _fetchFromCataas(count) {
        const response = await fetch(`https://cataas.com/api/cats?limit=${count}`);

        if (!response.ok) {
          throw new Error(`API returned ${response.status}: ${response.statusText}`);
        }

        const cats = await response.json();

        // Transform to normalized format
        return cats.map(cat => ({
          id: cat._id, // Real API ID!
          tags: cat.tags || [],
          // Build srcset for responsive images using width parameter
          baseUrl: `https://cataas.com/cat/${cat._id}`,
          srcset: [
            `https://cataas.com/cat/${cat._id}?width=400 400w`,
            `https://cataas.com/cat/${cat._id}?width=600 600w`,
            `https://cataas.com/cat/${cat._id}?width=800 800w`
          ].join(', '),
          sizes: '(max-width: 600px) 100vw, 600px',
          url: `https://cataas.com/cat/${cat._id}` // Default URL
        }));
      },

      /**
       * Refill cache in background (non-blocking)
       */
      async _refillCache() {
        // Don't refill if already have enough
        if (this.cache.length >= CONFIG.CACHE_SIZE) {
          return;
        }

        try {
          const needed = CONFIG.CACHE_SIZE - this.cache.length;
          this._log(`Refilling cache with ${needed} images...`);

          const images = await this._fetchFromAPI(needed);
          this.cache.push(...images);

          this._log(`Cache refilled. Now have ${this.cache.length} cached images`);
        } catch (error) {
          console.error('Failed to refill cache:', error);
        }
      },

      /**
       * Build image element with proper srcset
       */
      buildImageElement(imageData) {
        const wrapper = document.createElement('div');
        wrapper.className = 'image-wrapper';
        wrapper.dataset.imageId = imageData.id;

        const img = document.createElement('img');
        img.src = imageData.url;
        img.srcset = imageData.srcset; // Responsive images!
        img.sizes = imageData.sizes;
        img.alt = `Cat ${imageData.tags.length > 0 ? 'tagged: ' + imageData.tags.join(', ') : ''}`;
        img.loading = 'lazy';

        // Handle successful image load
        img.addEventListener('load', () => {
          wrapper.classList.add('loaded');
        });

        // Handle image load failure - silently remove
        img.addEventListener('error', () => {
          this._log(`Failed to load image: ${imageData.id}`, 'error');
          wrapper.remove();
        });

        wrapper.appendChild(img);

        // Add tags if available
        if (imageData.tags && imageData.tags.length > 0) {
          const tagsContainer = document.createElement('div');
          tagsContainer.className = 'image-tags';

          imageData.tags.slice(0, 3).forEach(tag => { // Max 3 tags
            const tagEl = document.createElement('span');
            tagEl.className = 'tag';
            tagEl.textContent = tag;
            tagsContainer.appendChild(tagEl);
          });

          wrapper.appendChild(tagsContainer);
        }

        return wrapper;
      },

      /**
       * Logging helper
       */
      _log(message, level = 'info') {
        if (CONFIG.DEV_MODE) {
          console[level](`[CatAPI] ${message}`);
        }
      }
    };

    // ===== 3. IMAGE MANAGER =====
    /**
     * Fetches and appends a batch of cat images
     */
    async function fetchNextBatch() {
      if (STATE.isLoading || STATE.hasError) {
        return;
      }

      STATE.isLoading = true;
      updateStats();

      try {
        const batchSize = STATE.isInitialLoad ? CONFIG.INITIAL_BATCH_SIZE : CONFIG.BATCH_SIZE;

        // Fetch with retry logic
        const images = await fetchWithRetry(() => CatAPI.fetch(batchSize));

        // Filter out duplicates using real API IDs
        const newImages = images.filter(img => {
          if (STATE.loadedImageIds.has(img.id)) {
            if (CONFIG.DEV_MODE) {
              console.warn(`Skipping duplicate image: ${img.id}`);
            }
            return false;
          }
          STATE.loadedImageIds.add(img.id);
          return true;
        });

        // Create DOM elements using DocumentFragment
        const fragment = document.createDocumentFragment();
        newImages.forEach(imageData => {
          const element = CatAPI.buildImageElement(imageData);
          fragment.appendChild(element);
        });

        // Append all images at once
        const container = document.getElementById('image-container');
        container.appendChild(fragment);

        STATE.totalLoaded += newImages.length;

        // Mark initial load as complete
        if (STATE.isInitialLoad) {
          STATE.isInitialLoad = false;
          if (CONFIG.DEV_MODE) {
            console.log(`Initial load complete: ${newImages.length} images`);
          }
        }

        // Clean up old images to manage memory
        cleanupOldImages();

      } catch (error) {
        console.error('Failed to fetch cat images:', error);
        STATE.hasError = true;
        showError('Failed to load images. Check console for details.');
      } finally {
        STATE.isLoading = false;
        updateStats();
      }
    }

    /**
     * Fetch with retry logic and exponential backoff
     */
    async function fetchWithRetry(fetchFn, retries = 0) {
      try {
        return await fetchFn();
      } catch (error) {
        if (retries < CONFIG.MAX_RETRIES) {
          const delay = CONFIG.RETRY_DELAYS[retries];
          console.log(`Fetch failed, retrying in ${delay}ms... (attempt ${retries + 1}/${CONFIG.MAX_RETRIES})`);
          await new Promise(resolve => setTimeout(resolve, delay));
          return fetchWithRetry(fetchFn, retries + 1);
        } else {
          console.error('Max retries reached, stopping fetch attempts');
          STATE.hasError = true;
          throw error;
        }
      }
    }

    // ===== 4. MEMORY MANAGEMENT =====
    /**
     * Remove images far above viewport to manage memory
     */
    function cleanupOldImages() {
      const container = document.getElementById('image-container');
      const images = container.querySelectorAll('.image-wrapper');

      if (images.length < 50) {
        // Don't clean up if we have fewer than 50 images
        return;
      }

      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const threshold = scrollTop - CONFIG.CLEANUP_THRESHOLD;

      let cleaned = 0;
      images.forEach(wrapper => {
        const rect = wrapper.getBoundingClientRect();
        const absoluteTop = rect.top + scrollTop;

        // Remove if image is far above viewport
        if (absoluteTop < threshold) {
          const imageId = wrapper.dataset.imageId;
          wrapper.remove();
          STATE.loadedImageIds.delete(imageId); // Allow it to be loaded again if needed
          cleaned++;
        }
      });

      if (cleaned > 0) {
        STATE.totalCleaned += cleaned;
        if (CONFIG.DEV_MODE) {
          console.log(`Cleaned up ${cleaned} images (total cleaned: ${STATE.totalCleaned})`);
        }
        updateStats();
      }
    }

    // ===== 5. SCROLL CONTROLLER & OBSERVER =====
    /**
     * Handles intersection events from the sentinel element
     */
    function handleIntersection(entries) {
      entries.forEach(entry => {
        if (entry.isIntersecting && !STATE.isLoading && !STATE.hasError) {
          fetchNextBatch();
        }
      });
    }

    /**
     * Initialize Intersection Observer
     */
    function initScrollObserver() {
      const sentinel = document.getElementById('sentinel');

      const observer = new IntersectionObserver(handleIntersection, {
        root: null,
        rootMargin: CONFIG.SCROLL_THRESHOLD,
        threshold: 0
      });

      observer.observe(sentinel);

      return observer;
    }

    // ===== 6. DEV MODE UTILITIES =====
    /**
     * Show error message (only in dev mode)
     */
    function showError(message) {
      if (!CONFIG.DEV_MODE) return;

      const toast = document.createElement('div');
      toast.className = 'error-toast';
      toast.textContent = message;
      document.body.appendChild(toast);

      setTimeout(() => {
        toast.remove();
      }, 5000);
    }

    /**
     * Update stats display (only in dev mode)
     */
    function updateStats() {
      if (!CONFIG.DEV_MODE) return;

      let statsEl = document.querySelector('.stats');
      if (!statsEl) {
        statsEl = document.createElement('div');
        statsEl.className = 'stats';
        document.body.appendChild(statsEl);
      }

      const activeImages = document.querySelectorAll('.image-wrapper').length;

      statsEl.innerHTML = `
        <div>üìä Stats</div>
        <div>Active: ${activeImages}</div>
        <div>Loaded: ${STATE.totalLoaded}</div>
        <div>Cleaned: ${STATE.totalCleaned}</div>
        <div>Cache hits: ${STATE.cacheHits}</div>
        <div>API calls: ${STATE.apiCalls}</div>
        <div>Cached: ${CatAPI.cache.length}</div>
      `;
    }

    /**
     * Show dev mode indicator
     */
    function showDevIndicator() {
      if (!CONFIG.DEV_MODE) return;

      const indicator = document.createElement('div');
      indicator.className = 'dev-indicator';
      indicator.textContent = 'üîß DEV MODE';
      document.body.appendChild(indicator);
    }

    // ===== 7. INITIALIZATION =====
    /**
     * Initialize the application
     */
    async function init() {
      // Show dev mode indicators
      showDevIndicator();
      updateStats();

      // Start observing scroll position
      initScrollObserver();

      // Pre-fill cache before initial load
      if (CONFIG.DEV_MODE) {
        console.log('Pre-filling cache...');
      }

      // Load initial batch immediately
      await fetchNextBatch();

      if (CONFIG.DEV_MODE) {
        console.log('Initialization complete!');
        console.log(`Viewport height: ${window.innerHeight}px`);
        console.log(`Initial batch size: ${CONFIG.INITIAL_BATCH_SIZE}`);
      }
    }

    // Start the app when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  </script>
</body>
</html>
